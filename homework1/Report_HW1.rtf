{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww28300\viewh15040\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b \cf0 Assignment1 Report :
\b0 \
\
Class Number: CS6240 Sec 01\
HW# 1\
Name : 
\i\b Rajkumar Murukeshan
\i0\b0 \
\
\

\b Weather Data Results:\
\

\i\b0 Execution Result for Question B:\
\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls1\ilvl0\cf0 {\listtext	1.	}
\i0\b Sequential Execution\uc0\u8232 
\f1\b0\fs22 Maximum time taken for Sequential: 6237\uc0\u8232 Minimum time taken for Sequential: 2337\u8232 Average time taken for Sequential: 2759\u8232 
\f0\b\fs24 \
\ls1\ilvl0
\i\b0 {\listtext	2.	}
\i0\b No Lock Execution
\i\b0 \uc0\u8232 
\f1\i0\fs22 Maximum time taken for No Lock: 796\uc0\u8232 Minimum time taken for No Lock: 651\u8232 Average time taken for No Lock: 676\u8232 \u8232 Speedup Achieved = 4.081\u8232 \
\ls1\ilvl0
\f0\i\fs24 {\listtext	3.	}
\i0\b Coarse Lock Execution
\i\b0 \uc0\u8232 
\f1\i0\fs22 Maximum time taken for Coarse Lock: 823\uc0\u8232 Minimum time taken for Coarse Lock: 746\u8232 Average time taken for Coarse Lock: 766\u8232 \u8232 SpeedUp Achieved = 3.601
\f0\i\fs24 \uc0\u8232 \
{\listtext	4.	}
\i0\b Fine Lock Execution
\i\b0 \uc0\u8232 
\f1\i0\fs22 Maximum time taken for Fine Lock: 729\uc0\u8232 Minimum time taken for Fine Lock: 653\u8232 Average time taken for Fine Lock: 669\u8232 \u8232 SpeedUp Achieved: 4.124\u8232 \
\ls1\ilvl0
\f0\i\fs24 {\listtext	5.	}
\i0\b No Sharing Execution
\i\b0 \uc0\u8232 
\f1\i0\fs22 Maximum time taken for No Sharing: 731\uc0\u8232 Minimum time taken for No Sharing: 659\u8232 Average time taken for No Sharing: 678\u8232 \u8232 SpeedUp Achieved: 4.069\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
Number of worker threads: 8\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\i\fs24 \cf0 \
Execution Result for Question C:\
\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural\partightenfactor0
\ls2\ilvl0\cf0 {\listtext	1.	}
\i0\b Sequential Execution\uc0\u8232 
\f1\b0\fs22 Maximum time taken for Sequential: 14843\uc0\u8232 Minimum time taken for Sequential: 11906\u8232 Average time taken for Sequential: 12421\u8232 
\f0\b\fs24 \
\ls2\ilvl0
\i\b0 {\listtext	2.	}
\i0\b No Lock Execution
\i\b0 \uc0\u8232 
\f1\i0\fs22 Maximum time taken for No Lock: 4768\uc0\u8232 Minimum time taken for No Lock: 3250\u8232 Average time taken for No Lock: 3457\u8232 \u8232 Speedup Achieved = 3.59\u8232 \
\ls2\ilvl0
\f0\i\fs24 {\listtext	3.	}
\i0\b Coarse Lock Execution
\i\b0 \uc0\u8232 
\f1\i0\fs22 Maximum time taken for Coarse Lock: 12527\uc0\u8232 Minimum time taken for Coarse Lock: 10462\u8232 Average time taken for Coarse Lock: 10721\u8232 \u8232 SpeedUp Achieved = 1.158
\f0\i\fs24 \uc0\u8232 \
{\listtext	4.	}
\i0\b Fine Lock Execution
\i\b0 \uc0\u8232 
\f1\i0\fs22 Maximum time taken for Fine Lock: 3515\uc0\u8232 Minimum time taken for Fine Lock: 3258\u8232 Average time taken for Fine Lock: 3313\u8232 \u8232 SpeedUp Achieved: 3.749\u8232 \
\ls2\ilvl0
\f0\i\fs24 {\listtext	5.	}
\i0\b No Sharing Execution
\i\b0 \uc0\u8232 
\f1\i0\fs22 Maximum time taken for No Sharing: 3621\uc0\u8232 Minimum time taken for No Sharing: 3572\u8232 Average time taken for No Sharing: 3498\u8232 \u8232 SpeedUp Achieved: 3.55\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
Number of worker threads: 8
\f0\i\fs24 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\i0\b \cf0 \
Questions & Answers :\
\
1) 
\f1\b0\fs22 \expnd0\expndtw0\kerning0
Which program version (SEQ, NO-LOCK, COARSE-LOCK, FINE-LOCK, NO-SHARING) would you normally expect to finish fastest and why? Do the experiments confirm your expectation? If not, try to explain the reasons\
Answer :  \
	Expected Result: No-Lock or Fine-Lock\
	Observed Result: Fine-Lock & No-Lock in two different executions (B & C). \
	\
	Explanations: In both No-Lock and Fine-Lock, there is a shared data structure (Hash map is being used in this case) and the input data is distributed to 8 threads. In No-Lock, there is no concurrency or synchronization, i.e. data structure is not locked while getting updated. In Fine-Lock, as the data structure is not locked on the whole and the lock is made at the object level, this method also has a better speed up.\
\
2)Which program version (SEQ, NO-LOCK, COARSE-LOCK, FINE-LOCK, NO-SHARING) would you normally expect to finish slowest and why? Do the experiments confirm your expectation? If not, try to explain the reasons.\
Answer: \
	Expected Result: Sequential program version\
	Observed Result: Sequential program version\
\
	Explanations: As there is no distribution of data for manipulation, sequential technique process the data step by step even though the process of each data is independent of other and it makes use of only one core. The remaining cores are made idle leading to more processing time and hence sequential is the slowest method in 5 program versions\
\
3)Compare the temperature averages returned by each program version. Report if any of them is incorrect.\
Answer: After comparing the result obtained by all the methods, we see that there is a deviation of result when using No-Lock Technique. Results obtained using Coarse-Lock, Fine-Lock and No-Sharing are matching with the results obtained using Sequential method, whereas the results obtained using No-Lock technique has few mismatches with the result obtained using Sequential technique.\
\
4)Compare the running times of SEQ and COARSE-LOCK. Try to explain why one is slower than the other. (Make sure to consider the results of both B and C\'97this might support or refute a possible hypothesis.)\
Answer: Coarse-Lock achieves a significant speedup with respect to sequential. It is because the coarse-lock distributes the data and performs pre-processing independently before locking the data structure. This is not similar to sequential, where pre-processing of data before adding to data structure is not performed in parallel even though the pre-processing of data is independent of each other and hence sequential method takes more time to run.\
\
5)How does the higher computation cost in part C (additional Fibonacci computation) affect the difference between COARSE-LOCK and FINE-LOCK? Try to explain the reason\
Answer: Higher computation cost increases the lock time of the data structure, thus affecting the run-time. In case of Coarse-lock, the entire data structure is locked and thus with higher computation, the lock-time increases, which increases the wait-time of other threads to access the data structure. This is not the case with Fine-lock, where the entire data structure is not locked and only the object is locked. This helps the threads which access different object in the same shared data structure to process without any wait-time, thus increasing the run time. \
	     \
			}